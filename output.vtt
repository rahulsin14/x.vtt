WEBVTT

00:00:00.240 --> 00:00:00.780
Hi.

00:00:00.790 --> 00:00:01.590
In this video,

00:00:01.590 --> 00:00:05.540
where when you talk about bitwise operators in seep listless,

00:00:06.040 --> 00:00:10.480
Please know that their are total six bed wise operators and C plus Plus,

00:00:10.940 --> 00:00:15.850
we are going to talk about first three in this medio and then Next Tree in the Next radio.

00:00:17.440 --> 00:00:20.090
Now what do we mean by a bitwise operator?

00:00:20.830 --> 00:00:25.160
Their are Mathematics operators that do addition subtraction,

00:00:25.160 --> 00:00:26.750
multiplication division.

00:00:27.340 --> 00:00:31.660
Their are logical operators that return values Like true and 

00:00:31.660 --> 00:00:32.350
false.

00:00:32.390 --> 00:00:37.060
They always deal where Tree windfalls their used inside the conditional statements 

00:00:37.060 --> 00:00:37.690
mostly,

00:00:38.000 --> 00:00:41.680
Like if while for bit ways,

00:00:41.680 --> 00:00:45.750
operators day work on Binary Implementation of numbers,

00:00:46.920 --> 00:00:51.890
the mainly operate on individual bits of the number that you past 

00:00:51.890 --> 00:00:51.960
two.

00:00:51.960 --> 00:00:56.300
These operators letters one begin bed Y IDE operators with these Tree 

00:00:56.300 --> 00:00:56.980
operators.

00:00:57.740 --> 00:01:02.600
First operator is bit wise and so we're bid wise and 

00:01:02.600 --> 00:01:03.660
operated us.

00:01:04.720 --> 00:01:09.310
It does bid wise end of by Implementation of two 

00:01:09.310 --> 00:01:09.950
numbers,

00:01:10.840 --> 00:01:15.790
so you must have extradited and here write an and a GATE produces and output 

00:01:15.790 --> 00:01:16.510
as one.

00:01:16.860 --> 00:01:19.030
If both in ports are one.

00:01:19.440 --> 00:01:21.310
In all other three Cases,

00:01:21.320 --> 00:01:22.580
it produces the output.

00:01:22.580 --> 00:01:23.200
Zero,

00:01:23.540 --> 00:01:24.740
if important,

00:01:24.740 --> 00:01:29.450
is 10 than Also 001 than Also zero both zero is than Also zero.

00:01:29.800 --> 00:01:34.750
It produces are put one only when both the inputs are one 

00:01:36.250 --> 00:01:41.110
bitwise or it produces the or could as one when 

00:01:41.120 --> 00:01:43.760
any of the imports are one write.

00:01:43.760 --> 00:01:44.570
For example,

00:01:44.580 --> 00:01:47.340
a share important is 11 X point to produce one,

00:01:47.710 --> 00:01:48.230
if important,

00:01:48.230 --> 00:01:52.750
01 and Also s want two Practice one if 10 then Also its going to produce one 

00:01:53.630 --> 00:01:58.310
in case of 100 is going to produce you so bad Y IDE or 

00:01:58.360 --> 00:02:02.360
produces one in three Cases and zero in one case,

00:02:02.800 --> 00:02:07.610
its kind of opposed of bitwise in which produces one only in one 

00:02:07.610 --> 00:02:09.560
case and zero in three Cases.

00:02:10.340 --> 00:02:13.150
Next operator is bid wise XOR,

00:02:14.410 --> 00:02:15.850
but ways XOR in interesting.

00:02:15.900 --> 00:02:20.480
It produces output as one when two in put beds are 

00:02:20.490 --> 00:02:25.250
different for 01 report is is one for 10 It Also 

00:02:25.250 --> 00:02:27.630
produces one for other Cases,

00:02:27.630 --> 00:02:29.040
Like 00 in one Month.

00:02:29.050 --> 00:02:32.310
It produces the output Test zero because both the bits are same.

00:02:32.520 --> 00:02:33.400
In both Cases,

00:02:33.400 --> 00:02:37.870
00 and 11 Let us now begin with first bitwise 

00:02:37.870 --> 00:02:38.490
operator,

00:02:38.500 --> 00:02:40.040
but was and left.

00:02:40.040 --> 00:02:41.030
See this example?

00:02:41.400 --> 00:02:44.170
We have input X s Tree and Y s six.

00:02:44.410 --> 00:02:46.490
And when we print as action,

00:02:46.490 --> 00:02:51.480
why we get the out Protests two at the output of first line is two that 

00:02:51.480 --> 00:02:55.350
See How two get this output two by Implementation trees.

00:02:55.350 --> 00:03:00.210
This we have 1st 30 bits as zero and then tore bits as 

00:03:00.210 --> 00:03:00.650
one.

00:03:01.110 --> 00:03:05.790
Considering that in teachers are represented is in 32 bids that their 

00:03:05.790 --> 00:03:07.990
represented using 60 for bits ban 1st,

00:03:07.990 --> 00:03:12.830
62 bits will be zero and last two bits will be one by 

00:03:12.830 --> 00:03:17.750
any representation of why which is six is going to have 110 at the end.

00:03:18.340 --> 00:03:22.740
Last neighbours and if in digit are represented using 32 

00:03:22.740 --> 00:03:27.670
beds than 1st 29 bits are going to be zero plea New.

00:03:27.670 --> 00:03:32.530
That number of bits require two represented in d jer is 

00:03:32.530 --> 00:03:34.260
not standardise.

00:03:34.270 --> 00:03:37.130
Its not mentioned in this even List.

00:03:37.130 --> 00:03:42.080
Plus a standard compilers are free to choose any size 

00:03:42.540 --> 00:03:43.230
sum Come by.

00:03:43.230 --> 00:03:45.610
Layers have in teacher size is 32 bits.

00:03:45.620 --> 00:03:47.460
Sum Compiler is have 60 for bits,

00:03:47.760 --> 00:03:50.150
sum hold compilers even of 16 bills.

00:03:50.160 --> 00:03:51.570
So that is Y used dot,

00:03:51.570 --> 00:03:56.230
dot dot So these first bits might be 30 bits or their might be 62 kids.

00:03:56.660 --> 00:03:57.260
Similarly,

00:03:57.260 --> 00:04:00.990
here these zeros might be 29 bits or 61 bits.

00:04:00.990 --> 00:04:05.450
If the stay for better presentational used now be do bitwise end of these two.

00:04:06.240 --> 00:04:11.000
Please remember the rule of bitwise and it produces one only when both in 

00:04:11.000 --> 00:04:11.500
Porter one.

00:04:12.940 --> 00:04:14.660
So we have 10 different.

00:04:14.660 --> 00:04:18.030
We have output 011 same and both are one.

00:04:18.040 --> 00:04:22.960
So are Practice one 010 and all 

00:04:22.960 --> 00:04:26.650
the Previous bits their any ways by New produce zero because they all are zero.

00:04:27.050 --> 00:04:29.250
What is Decimal representation of this number?

00:04:29.740 --> 00:04:34.040
Here is a number which has all the leading bits zero except the last two bits.

00:04:34.410 --> 00:04:38.540
And last second last bit is one and its last Minute zero true Decimal.

00:04:38.540 --> 00:04:40.550
If element of the sum Mar is two,

00:04:41.000 --> 00:04:42.890
that is by Y get the all Prada's two.

00:04:42.900 --> 00:04:47.600
When we parent bitwise and of Tree in for let us now talk 

00:04:47.600 --> 00:04:51.790
about bid wise or operator bitwise or operator.

00:04:51.800 --> 00:04:56.350
If produces the output as one when any of the input bits are one,

00:04:56.910 --> 00:04:59.090
so we have to number section Why?

00:04:59.100 --> 00:05:00.950
Whose bit ways or we want to find out.

00:05:01.430 --> 00:05:05.020
Please note that these operators are called better wise,

00:05:05.020 --> 00:05:07.580
but the produce output does in in digit only night.

00:05:07.580 --> 00:05:08.400
They do internally,

00:05:08.400 --> 00:05:13.010
but Y IDE operators operations and then consider the Decimal 

00:05:13.010 --> 00:05:17.450
value after doing the bit Y operations then return that Decimal value 

00:05:18.120 --> 00:05:19.250
as a result.

00:05:20.520 --> 00:05:25.490
So three and six their by any Implementation are reason these And 

00:05:25.490 --> 00:05:27.670
when you do bitwise or of X,

00:05:27.670 --> 00:05:32.600
and while not See would do we get 10 bid wise or is going 

00:05:32.600 --> 00:05:37.170
to be one 11 bed ways or or it is going to be one while in one 

00:05:37.170 --> 00:05:39.430
because one of the bits is set here.

00:05:39.430 --> 00:05:41.540
Both are sets of one here again,

00:05:41.540 --> 00:05:44.650
one by districts of one for remaining pairs,

00:05:45.400 --> 00:05:46.480
as all going of is zero.

00:05:46.480 --> 00:05:51.460
Because all the remaining bits on the leading bits are zero sour output is going to be a 

00:05:51.460 --> 00:05:56.020
number which has last three bits as one and remaining leading bits.

00:05:56.020 --> 00:05:57.560
A zero is you zero IDE.

00:05:57.560 --> 00:06:02.460
If it is the 30 to build a presentation that this twenties are 29 zeros affected 60 for 

00:06:02.460 --> 00:06:03.260
better presentation.

00:06:03.260 --> 00:06:04.490
These are 16 1 CEOs,

00:06:04.690 --> 00:06:07.350
but these are Also here was only the last Time bit Search set.

00:06:07.740 --> 00:06:12.610
So what is the Decimal equal IND of this Binary this corresponds of one discussed wanted to 

00:06:12.610 --> 00:06:14.180
this Christmas of force of vote List two.

00:06:14.180 --> 00:06:18.940
Place 17 that is Y get the all protest level in this program for these second 

00:06:18.940 --> 00:06:19.250
line.

00:06:20.220 --> 00:06:23.240
It does now talk about our Next bitwise operator,

00:06:23.310 --> 00:06:24.850
which is XOR operator.

00:06:25.570 --> 00:06:30.440
XOR operator produces the or port one only when two input bits 

00:06:30.440 --> 00:06:31.250
are different.

00:06:31.640 --> 00:06:36.250
So we have given the numbers as Tree you in six These are their by near presentations.

00:06:37.440 --> 00:06:42.050
When we do bitwise XOR be produced the output as one only when their 

00:06:42.050 --> 00:06:43.830
different so one and zero their different.

00:06:43.840 --> 00:06:45.350
So we produce the or put as one,

00:06:45.740 --> 00:06:50.340
one and one their saves over all present zero and one their 

00:06:50.340 --> 00:06:50.820
different.

00:06:50.820 --> 00:06:51.850
So over output is one.

00:06:52.530 --> 00:06:54.750
Now the consider remaining leading beds.

00:06:55.190 --> 00:06:57.120
They are all zero in both of them,

00:06:57.170 --> 00:06:59.550
so they are all going to be shame in both of them.

00:06:59.940 --> 00:07:04.780
So we have a number in the result whose last Tree bits are 101 

00:07:05.090 --> 00:07:08.120
and remaining leading bits are all zero a facts.

00:07:08.120 --> 00:07:13.090
A 22 bit number than these are 29 bits affects the 60 for with number than the your 61 be 

00:07:13.090 --> 00:07:13.650
zeros.

00:07:14.140 --> 00:07:14.400
Now,

00:07:14.400 --> 00:07:16.250
odd is d Decimal equal int of this number,

00:07:16.640 --> 00:07:18.640
its one plus for five.

00:07:19.210 --> 00:07:23.840
So we get the our code a five when we do bitwise XOR of ash and Y.

00:07:19.210 --> 00:07:23.840
